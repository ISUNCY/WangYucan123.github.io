<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>五子棋电脑版下载</title>
      <link href="2020/11/14/%E4%BA%94%E5%AD%90%E6%A3%8B/"/>
      <url>2020/11/14/%E4%BA%94%E5%AD%90%E6%A3%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="五子棋电脑版"><a href="#五子棋电脑版" class="headerlink" title="五子棋电脑版"></a>五子棋电脑版</h1><p><strong>本游戏由C语言+easyx图形库制作，制作者：奇光灿烂</strong></p><h2 id="效果展示："><a href="#效果展示：" class="headerlink" title="效果展示："></a>效果展示：</h2><h4 id="初始界面："><a href="#初始界面：" class="headerlink" title="初始界面："></a>初始界面：</h4><p><img src="https://cdn.jsdelivr.net/gh/wangyucan123/wangyucan123.github.io/2020/11/14/%E4%BA%94%E5%AD%90%E6%A3%8B/%E6%8F%8F%E8%BF%B01.png" alt="五子棋效果展示" title="五子棋效果展示"><br>可以选择“开始游戏”、“退出游戏”或“关于”。</p><h4 id="开始游戏："><a href="#开始游戏：" class="headerlink" title="开始游戏："></a>开始游戏：</h4><p><img src="https://cdn.jsdelivr.net/gh/wangyucan123/wangyucan123.github.io/2020/11/14/%E4%BA%94%E5%AD%90%E6%A3%8B/%E6%8F%8F%E8%BF%B02.png" alt="五子棋效果展示" title="五子棋效果展示"><br>游戏右侧的边栏显示行棋方、回合数、已用时间以及对局结果。</p><h4 id="黑棋胜："><a href="#黑棋胜：" class="headerlink" title="黑棋胜："></a>黑棋胜：</h4><p><img src="https://cdn.jsdelivr.net/gh/wangyucan123/wangyucan123.github.io/2020/11/14/%E4%BA%94%E5%AD%90%E6%A3%8B/%E6%8F%8F%E8%BF%B03.png" alt="五子棋效果展示" title="五子棋效果展示"><br>此外，本游戏还带有背景音乐，可以自行下载尝试^_^。</p><h4 id="游戏源代码："><a href="#游戏源代码：" class="headerlink" title="游戏源代码："></a>游戏源代码：</h4><pre><code>#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;graphics.h&gt;#include &lt;windows.h&gt;#include &lt;mmsystem.h&gt;#include &lt;stdlib.h&gt;#include &lt;conio.h&gt;#pragma comment(lib,&quot;Winmm.lib&quot;)#define WIDTH  680    //窗口宽度#define HEIGHT 680    //窗口高度IMAGE bk1;                    //开始界面背景图片IMAGE bk2;                    //游戏中背景图片MOUSEMSG msg;                //鼠标消息bool black = true;            //判断棋子是否为黑色int blackWin;                //判断黑方是否获胜（值为1时黑方胜，为-1时白方胜，为2时为平局，为0时则未分胜负）int rounds = 0;                //回合数struct Chess&#123;    bool isChess = false;    //判断此处是否有棋子    int x;                    //棋子的x坐标    int y;                    //棋子的y坐标    bool black;                //棋子的颜色是否为黑色    bool lately = false;    //是否为最近一次下的棋&#125;GameMap[18][18];void initdata(void);        //初始化数据int beginGame(void);        //游戏开始界面void drawMap(void);            //画出地图void changeMap(void);        //改变地图（用户落子）void WinOrLose(void);        //判断胜负int main(void)&#123;    initgraph(WIDTH, HEIGHT);    BeginBatchDraw();    initdata();                    //初始化数据    if (beginGame() == -1)        //开始界面    &#123;        closegraph();        return 0;    &#125;    closegraph();    initgraph(WIDTH + 220, HEIGHT);        //重新创建一个大一点的窗口    initdata();    BeginBatchDraw();    cleardevice();    mciSendString(&quot;play .//src//music//高山流水.mp3 repeat&quot;, 0, 0, 0);    //循环播放背景音乐    HANDLE handle;    //创建一个线程来画地图    handle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)drawMap, NULL, NULL, NULL);    while (1)            //循环改变地图，画地图    &#123;        changeMap();    &#125;    closegraph();    return 0;&#125;//初始化数据void initdata(void)&#123;    settextcolor(LIGHTGREEN);    setbkcolor(RGB(230, 230, 230));    cleardevice();    setlinecolor(BLACK);    setbkmode(TRANSPARENT);    loadimage(&amp;bk1, &quot;.//src//image//bk1.jpg&quot;, WIDTH, HEIGHT);    loadimage(&amp;bk2, &quot;.//src//image//bk2.jpg&quot;, WIDTH, HEIGHT);&#125;//游戏开始界面int beginGame(void)&#123;    putimage(0, 0, &amp;bk1);    settextstyle(90, 0, &quot;楷体&quot;);    outtextxy(220, 10, &quot;五子棋&quot;);    settextcolor(BROWN);    setfillcolor(RGB(255, 255, 0));    settextstyle(HEIGHT / 5 * 1 / 2, 0, &quot;楷体&quot;);    outtextxy((WIDTH - textwidth(&quot;开始&quot;)) / 2, (HEIGHT / 5 * 3) - textheight(&quot;开始&quot;), &quot;开始&quot;);    outtextxy((WIDTH - textwidth(&quot;退出&quot;)) / 2, (HEIGHT / 5 * 4) - textheight(&quot;退出&quot;), &quot;退出&quot;);    outtextxy((WIDTH - textwidth(&quot;关于&quot;)) / 2, (HEIGHT / 5 * 5) - textheight(&quot;关于&quot;), &quot;关于&quot;);    FlushBatchDraw();    while (1)    &#123;        if (MouseHit())            msg = GetMouseMsg();        if (msg.x &gt; (WIDTH - textwidth(&quot;开始&quot;)) / 2 &amp;&amp;            msg.y &gt; (HEIGHT / 5 * 3) - textheight(&quot;开始&quot;) &amp;&amp;            msg.x &lt; (WIDTH - textwidth(&quot;开始&quot;)) / 2 + textwidth(&quot;开始&quot;) &amp;&amp;            msg.y &lt; (HEIGHT / 5 * 3) - textheight(&quot;开始&quot;) + textwidth(&quot;开始&quot;) / 2)        &#123;            fillroundrect((WIDTH - textwidth(&quot;开始&quot;)) / 2, (HEIGHT / 5 * 3) - textheight(&quot;开始&quot;),                (WIDTH - textwidth(&quot;开始&quot;)) / 2 + textwidth(&quot;开始&quot;),                (HEIGHT / 5 * 3) - textheight(&quot;开始&quot;) + textwidth(&quot;开始&quot;) / 2,                10, 10);            outtextxy((WIDTH - textwidth(&quot;开始&quot;)) / 2, (HEIGHT / 5 * 3) - textheight(&quot;开始&quot;), &quot;开始&quot;);        &#125;        if (msg.x &gt;(WIDTH - textwidth(&quot;退出&quot;)) / 2 &amp;&amp;            msg.y &gt;(HEIGHT / 5 * 4) - textheight(&quot;退出&quot;) &amp;&amp;            msg.x &lt; (WIDTH - textwidth(&quot;退出&quot;)) / 2 + textwidth(&quot;退出&quot;) &amp;&amp;            msg.y &lt; (HEIGHT / 5 * 4) - textheight(&quot;退出&quot;) + textwidth(&quot;退出&quot;) / 2)        &#123;            fillroundrect((WIDTH - textwidth(&quot;退出&quot;)) / 2, (HEIGHT / 5 * 4) - textheight(&quot;退出&quot;),                (WIDTH - textwidth(&quot;退出&quot;)) / 2 + textwidth(&quot;退出&quot;),                (HEIGHT / 5 * 4) - textheight(&quot;退出&quot;) + textwidth(&quot;退出&quot;) / 2,                10, 10);            outtextxy((WIDTH - textwidth(&quot;退出&quot;)) / 2, (HEIGHT / 5 * 4) - textheight(&quot;退出&quot;), &quot;退出&quot;);        &#125;        if (msg.x &gt;(WIDTH - textwidth(&quot;关于&quot;)) / 2 &amp;&amp;            msg.y &gt;(HEIGHT / 5 * 5) - textheight(&quot;关于&quot;) &amp;&amp;            msg.x &lt; (WIDTH - textwidth(&quot;关于&quot;)) / 2 + textwidth(&quot;关于&quot;) &amp;&amp;            msg.y &lt; (HEIGHT / 5 * 5) - textheight(&quot;关于&quot;) + textwidth(&quot;关于&quot;) / 2)        &#123;            fillroundrect((WIDTH - textwidth(&quot;关于&quot;)) / 2, (HEIGHT / 5 * 5) - textheight(&quot;关于&quot;),                (WIDTH - textwidth(&quot;关于&quot;)) / 2 + textwidth(&quot;关于&quot;),                (HEIGHT / 5 * 5) - textheight(&quot;关于&quot;) + textwidth(&quot;关于&quot;) / 2,                10, 10);            outtextxy((WIDTH - textwidth(&quot;关于&quot;)) / 2, (HEIGHT / 5 * 5) - textheight(&quot;关于&quot;), &quot;关于&quot;);        &#125;        if (msg.uMsg == WM_LBUTTONUP)        &#123;            if (msg.x &gt;(WIDTH - textwidth(&quot;开始&quot;)) / 2 &amp;&amp;                msg.y &gt; (HEIGHT / 5 * 3) - textheight(&quot;开始&quot;) &amp;&amp;                msg.x &lt; (WIDTH - textwidth(&quot;开始&quot;)) / 2 + textwidth(&quot;开始&quot;) &amp;&amp;                msg.y &lt; (HEIGHT / 5 * 3) - textheight(&quot;开始&quot;) + textwidth(&quot;开始&quot;) / 2)            &#123;                return 0;            &#125;            if (msg.x &gt;(WIDTH - textwidth(&quot;退出&quot;)) / 2 &amp;&amp;                msg.y &gt;(HEIGHT / 5 * 4) - textheight(&quot;退出&quot;) &amp;&amp;                msg.x &lt; (WIDTH - textwidth(&quot;退出&quot;)) / 2 + textwidth(&quot;退出&quot;) &amp;&amp;                msg.y &lt; (HEIGHT / 5 * 4) - textheight(&quot;退出&quot;) + textwidth(&quot;退出&quot;) / 2)            &#123;                closegraph();                return -1;            &#125;            if (msg.x &gt;(WIDTH - textwidth(&quot;关于&quot;)) / 2 &amp;&amp;                msg.y &gt;(HEIGHT / 5 * 5) - textheight(&quot;关于&quot;) &amp;&amp;                msg.x &lt; (WIDTH - textwidth(&quot;关于&quot;)) / 2 + textwidth(&quot;关于&quot;) &amp;&amp;                msg.y &lt; (HEIGHT / 5 * 5) - textheight(&quot;关于&quot;) + textwidth(&quot;关于&quot;) / 2)            &#123;                cleardevice();                settextstyle(20, 0, &quot;楷体&quot;);                outtextxy(0, 0, &quot;本应用用c/c++编写,作者:王宇灿&quot;);                FlushBatchDraw();                Sleep(3000);            &#125;        &#125;        if (!((msg.x &gt;(WIDTH - textwidth(&quot;开始&quot;)) / 2 &amp;&amp;            msg.y &gt; (HEIGHT / 5 * 3) - textheight(&quot;开始&quot;) &amp;&amp;            msg.x &lt; (WIDTH - textwidth(&quot;开始&quot;)) / 2 + textwidth(&quot;开始&quot;) &amp;&amp;            msg.y &lt; (HEIGHT / 5 * 3) - textheight(&quot;开始&quot;) + textwidth(&quot;开始&quot;) / 2) ||            (msg.x &gt;(WIDTH - textwidth(&quot;退出&quot;)) / 2 &amp;&amp;            msg.y &gt;(HEIGHT / 5 * 4) - textheight(&quot;退出&quot;) &amp;&amp;            msg.x &lt; (WIDTH - textwidth(&quot;退出&quot;)) / 2 + textwidth(&quot;退出&quot;) &amp;&amp;            msg.y &lt; (HEIGHT / 5 * 4) - textheight(&quot;退出&quot;) + textwidth(&quot;退出&quot;) / 2) ||            (msg.x &gt;(WIDTH - textwidth(&quot;关于&quot;)) / 2 &amp;&amp;            msg.y &gt;(HEIGHT / 5 * 5) - textheight(&quot;关于&quot;) &amp;&amp;            msg.x &lt; (WIDTH - textwidth(&quot;关于&quot;)) / 2 + textwidth(&quot;关于&quot;) &amp;&amp;            msg.y &lt; (HEIGHT / 5 * 5) - textheight(&quot;关于&quot;) + textwidth(&quot;关于&quot;) / 2)))        &#123;            putimage(0, 0, &amp;bk1);            settextcolor(LIGHTGREEN);            settextstyle(90, 0, &quot;楷体&quot;);            outtextxy(220, 10, &quot;五子棋&quot;);            settextcolor(BROWN);            setfillcolor(RGB(255, 255, 0));            settextstyle(HEIGHT / 5 * 1 / 2, 0, &quot;楷体&quot;);            outtextxy((WIDTH - textwidth(&quot;开始&quot;)) / 2, (HEIGHT / 5 * 3) - textheight(&quot;开始&quot;), &quot;开始&quot;);            outtextxy((WIDTH - textwidth(&quot;退出&quot;)) / 2, (HEIGHT / 5 * 4) - textheight(&quot;退出&quot;), &quot;退出&quot;);            outtextxy((WIDTH - textwidth(&quot;关于&quot;)) / 2, (HEIGHT / 5 * 5) - textheight(&quot;关于&quot;), &quot;关于&quot;);        &#125;        FlushBatchDraw();    &#125;&#125;//画地图void drawMap(void)&#123;    while (1)    &#123;        cleardevice();        putimage(0, 0, &amp;bk2);        setlinecolor(BLACK);        for (int i = 0; i &lt; 18; i++)        &#123;            for (int j = 0; j &lt;= 18; j++)            &#123;                line(i * 40, 0, i * 40, WIDTH);                line(0, j * 40, HEIGHT, j * 40);            &#125;        &#125;        setfillcolor(RED);        solidcircle(WIDTH / 2 - 20, HEIGHT / 2 - 20, 3);                        //中间的小黑点        solidcircle(WIDTH / 2 - 40 * 4 - 20, HEIGHT / 2 - 40 * 4 - 20, 3);        //左上角的小黑点        solidcircle(WIDTH / 2 + 40 * 4 - 20, HEIGHT / 2 - 40 * 4 - 20, 3);        //右上角的小黑点        solidcircle(WIDTH / 2 - 40 * 4 - 20, HEIGHT / 2 + 40 * 4 - 20, 3);        //左下角的小黑点        solidcircle(WIDTH / 2 + 40 * 4 - 20, HEIGHT / 2 + 40 * 4 - 20, 3);        //右下角的小黑点        solidcircle(WIDTH / 2 - 20, HEIGHT / 2 + 40 * 4 - 20, 3);                //下面的小黑点        solidcircle(WIDTH / 2 - 20, HEIGHT / 2 - 40 * 4 - 20, 3);                //上面的小黑点        solidcircle(WIDTH / 2 - 40 * 4 - 20, HEIGHT / 2 - 20, 3);                //左面的小黑点        solidcircle(WIDTH / 2 + 40 * 4 - 20, HEIGHT / 2 - 20, 3);                //右面的小黑点        //根据GameMap的值画出棋子        for (int i = 0; i &lt; 18; i++)        &#123;            for (int j = 0; j &lt; 18; j++)            &#123;                if (GameMap[i][j].isChess)                &#123;                    if (GameMap[i][j].black)&#123;                        setfillcolor(BLACK);                    &#125;                    else                    &#123;                        setfillcolor(WHITE);                    &#125;                    solidcircle(GameMap[i][j].x, GameMap[i][j].y, 10);                    if (GameMap[i][j].lately)&#123;                        setfillcolor(LIGHTRED);                        solidcircle(GameMap[i][j].x, GameMap[i][j].y, 3);                        GameMap[i][j].lately = false;                    &#125;                &#125;            &#125;        &#125;        WinOrLose();                //判断胜负        //画出右侧提示框        setfillcolor(RGB(200, 200, 200));        solidrectangle(WIDTH, 0, WIDTH + 10, HEIGHT);        //显示对局结果        settextstyle(20, 0, &quot;宋体&quot;);        settextcolor(LIGHTGREEN);        outtextxy(WIDTH + 10, 10, &quot;对局结果：&quot;);        settextstyle(30, 0, &quot;楷体&quot;);        if (blackWin == 1)        &#123;            settextcolor(LIGHTBLUE);            outtextxy(WIDTH + 100, 0, &quot;黑方胜利！&quot;);        &#125;        else if (blackWin == -1)        &#123;            settextcolor(LIGHTRED);            outtextxy(WIDTH + 100, 0, &quot;白方胜利！&quot;);        &#125;        else if (blackWin == 2)        &#123;            settextcolor(RGB(255, 0, 255));            outtextxy(WIDTH + 100, 0, &quot;平局！&quot;);            FlushBatchDraw();            getchar();        &#125;        else        &#123;            settextcolor(RGB(50, 50, 50));            outtextxy(WIDTH + 100, 0, &quot;未分胜负&quot;);        &#125;        //显示执行方        settextstyle(20, 0, &quot;宋体&quot;);        settextcolor(RGB(185, 122, 87));        outtextxy(WIDTH + 10, 50, &quot;行棋方：&quot;);        settextstyle(30, 0, &quot;楷体&quot;);        if (black)&#123;            settextcolor(LIGHTBLUE);            outtextxy(WIDTH + 80, 45, &quot;黑方&quot;);        &#125;        else        &#123;            settextcolor(LIGHTRED);            outtextxy(WIDTH + 80, 45, &quot;白方&quot;);        &#125;        //显示回合数        settextstyle(20, 0, &quot;宋体&quot;);        settextcolor(LIGHTBLUE);        outtextxy(WIDTH + 10, 90, &quot;回合数：&quot;);        settextstyle(30, 0, NULL);        settextcolor(RGB(255, 127, 39));            //橘色        char rounds_s[10];                            //outtextxy不支持打印int类型，所以转换为字符串类型(round_str)        sprintf_s(rounds_s, &quot;%d&quot;, rounds);        outtextxy(WIDTH + 80, 85, rounds_s);        //itoa()函数功能是：把整形数值转换为字符串，以此实现打印输出        //显示已用时间        settextstyle(20, 0, &quot;宋体&quot;);        settextcolor(RGB(120, 50, 140));        outtextxy(WIDTH + 10, 130, &quot;已用时间：&quot;);        settextstyle(30, 0, &quot;宋体&quot;);        settextcolor(RGB(40, 240, 230));        static int FirstTime = (int)time(NULL);        //首次记录值        int nowTime = (int)time(NULL);                //现在的时间        char time_s[10];                        //已用时间（time_str）        sprintf_s(time_s, &quot;%d:%d:%d&quot;, (nowTime - FirstTime) / 3600 % 60, (nowTime - FirstTime) / 60 % 60, (nowTime - FirstTime) % 60);        outtextxy(WIDTH + 100, 125, time_s);        FlushBatchDraw();        if (blackWin != 0)            getchar();        Sleep(50);            //为防止cpu占用率过高和闪屏，小睡一下    &#125;&#125;//改变地图（用户落子）void changeMap(void)&#123;    msg = GetMouseMsg();    while (msg.uMsg == WM_MOUSEMOVE || msg.uMsg == WM_LBUTTONUP)    &#123;        msg = GetMouseMsg();    &#125;    if (msg.uMsg == WM_LBUTTONDOWN)    &#123;        //通过判断鼠标位置，确定棋子位置        for (int i = 0; i &lt;= WIDTH; i += 40)        &#123;            for (int j = 0; j &lt;= HEIGHT; j += 40)            &#123;                if (msg.x &gt; i - 20 &amp;&amp; msg.y &gt; j - 20 &amp;&amp; msg.x &lt; i + 20 &amp;&amp; msg.y &lt; j + 20 &amp;&amp; !GameMap[i / 40][j / 40].isChess)                &#123;                    GameMap[i / 40][j / 40].isChess = true;                    GameMap[i / 40][j / 40].x = i;                    GameMap[i / 40][j / 40].y = j;                    if (black)                    &#123;                        GameMap[i / 40][j / 40].black = true;                        black = false;                    &#125;                    else                    &#123;                        GameMap[i / 40][j / 40].black = false;                        black = true;                        rounds++;                    &#125;                    GameMap[i / 40][j / 40].lately = true;                &#125;            &#125;        &#125;    &#125;&#125;//判断胜负void WinOrLose(void)&#123;    int filled = 0;                        //判断棋盘是否充满    for (int i = 0; i &lt; 25; i++)    &#123;        for (int j = 0; j &lt; 25; j++)        &#123;            //横排为5个            if (GameMap[i][j].isChess &amp;&amp; GameMap[i + 1][j].isChess &amp;&amp; GameMap[i + 2][j].isChess &amp;&amp;                GameMap[i + 3][j].isChess &amp;&amp; GameMap[i + 4][j].isChess &amp;&amp;                GameMap[i][j].black == GameMap[i + 1][j].black &amp;&amp;                GameMap[i][j].black == GameMap[i + 4][j].black &amp;&amp;                GameMap[i + 2][j].black == GameMap[i + 3][j].black &amp;&amp;                GameMap[i + 2][j].black == GameMap[i][j].black)&#123;                setlinecolor(LIGHTRED);                line(GameMap[i][j].x, GameMap[i][j].y, GameMap[i + 4][j].x, GameMap[i + 4][j].y);                if (GameMap[i][j].black)                    blackWin = 1;                else                    blackWin = -1;            &#125;            //竖排有5个            else if (GameMap[i][j].isChess &amp;&amp; GameMap[i][j + 1].isChess &amp;&amp; GameMap[i][j + 2].isChess &amp;&amp;                GameMap[i][j + 3].isChess &amp;&amp; GameMap[i][j + 4].isChess &amp;&amp;                GameMap[i][j].black == GameMap[i][j + 1].black &amp;&amp;                GameMap[i][j].black == GameMap[i][j + 4].black &amp;&amp;                GameMap[i][j + 2].black == GameMap[i][j + 3].black &amp;&amp;                GameMap[i][j + 2].black == GameMap[i][j].black)&#123;                setlinecolor(LIGHTRED);                line(GameMap[i][j].x, GameMap[i][j].y, GameMap[i][j + 4].x, GameMap[i][j + 4].y);                if (GameMap[i][j].black)                    blackWin = 1;                else                    blackWin = -1;            &#125;            //右斜有5个            else if (GameMap[i][j].isChess &amp;&amp; GameMap[i + 1][j + 1].isChess &amp;&amp; GameMap[i + 2][j + 2].isChess &amp;&amp;                GameMap[i + 3][j + 3].isChess &amp;&amp; GameMap[i + 4][j + 4].isChess &amp;&amp;                GameMap[i][j].black == GameMap[i + 1][j + 1].black &amp;&amp;                GameMap[i + 1][j + 1].black == GameMap[i + 4][j + 4].black &amp;&amp;                GameMap[i + 2][j + 2].black == GameMap[i + 3][j + 3].black &amp;&amp;                GameMap[i + 2][j + 2].black == GameMap[i][j].black)&#123;                setlinecolor(LIGHTRED);                line(GameMap[i][j].x, GameMap[i][j].y, GameMap[i + 4][j + 4].x, GameMap[i + 4][j + 4].y);                if (GameMap[i][j].black)                    blackWin = 1;                else                    blackWin = -1;            &#125;            //左斜有5个            else if (GameMap[i][j].isChess &amp;&amp; GameMap[i - 1][j + 1].isChess &amp;&amp; GameMap[i - 2][j + 2].isChess &amp;&amp;                GameMap[i - 3][j + 3].isChess &amp;&amp; GameMap[i - 4][j + 4].isChess &amp;&amp;                GameMap[i][j].black == GameMap[i - 1][j + 1].black &amp;&amp;                GameMap[i - 1][j + 1].black == GameMap[i - 4][j + 4].black &amp;&amp;                GameMap[i - 2][j + 2].black == GameMap[i - 3][j + 3].black &amp;&amp;                GameMap[i - 2][j + 2].black == GameMap[i][j].black)&#123;                setlinecolor(LIGHTRED);                line(GameMap[i][j].x, GameMap[i][j].y, GameMap[i - 4][j + 4].x, GameMap[i - 4][j + 4].y);                if (GameMap[i][j].black)                    blackWin = 1;                else                    blackWin = -1;            &#125;            //判断棋子是否充满棋盘            if (GameMap[i][j].isChess)                filled++;            if (filled == 18 * 18)                blackWin = 2;        &#125;    &#125;&#125;</code></pre><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h5 id="运行环境：WindowsXP-Windows7-Windows8-Windows10"><a href="#运行环境：WindowsXP-Windows7-Windows8-Windows10" class="headerlink" title="运行环境：WindowsXP, Windows7, Windows8, Windows10"></a>运行环境：WindowsXP, Windows7, Windows8, Windows10</h5><h4 id="下载方式一：安装包"><a href="#下载方式一：安装包" class="headerlink" title="下载方式一：安装包"></a>下载方式一：安装包</h4><p>注：</p><ul><li>下载后运行“五子棋安装程序.exe”即可安装；</li><li>会自动在桌面生成快捷方式，点击即可运行；</li><li>如要卸载，请运行开始菜单中的卸载程序。</li></ul><p>下载链接：<a href="https://vip.d0.baidupan.com/file/?UDZbZQ4/Dz5UXVZuCz5VOVtkVGxe5QuzC5gD4ALzBJVQtlGlW40HfVN3UGcKLFJ1BzsPY1BjCm1QCAFuADhWalBjWz4OZQ9qVDJWNwtuVWVbJ1Q3XnILNAs4AzYCZwQ2UGNRMFs/B3VTdVB2CmNSYQdtDzhQPwonUGYBNgBzVmZQZFsjDmQPOFQ6VmQLZlU1WzlUZ15kCzwLNQMyAmoEYFAyUTNbPgc2UzZQNQppUjcHPA8zUDoKbVBmAWQAOVZjUGZbNA59DylUY1ZyC3lVIVtyVDRecwtgC2gDOAJvBDJQYlEwWzYHa1MxUCAKKlI6BzAPb1BpCjVQZgExAGxWYlBjWzgOZw9pVDFWNAtxVXpbJ1Q3Xm0LfgsxAzQCaAQ1UGVRNVsyB2BTNFA2CmZSdQcoD3pQeAo1UGYBMQBsVmJQY1s/DmUPbFQ1VjgLeVUhW2hUIV48CzsLOwMrAm8EPVBmUShbNwdmUzdQKApmUmI=" title="五子棋安装程序.exe">五子棋安装程序.exe</a><br>备用下载链接：<a href="https://wws.lanzous.com/iMdONidwzle" title="五子棋安装程序.exe">五子棋安装程序.exe</a></p><h4 id="下载方式二：免安装版"><a href="#下载方式二：免安装版" class="headerlink" title="下载方式二：免安装版"></a>下载方式二：免安装版</h4><p>注：下载后为压缩包，解压后运行“五子棋.exe”即可<br>下载链接：<a href="https://vip.d0.baidupan.com/file/?A2UGOFxtVWQIAVBoU2ZTPwQ7UGhS6QO7BJcD4Ab3B5ZXsVCkWY9TKQUhU2RXcVVyUGxVOQc0BGMAWFU6XWVUaAMwBmNcN1UwCG5QMVM2U2MEeFAzUn4DPAQ3AzYGYwc1V2RQMVk9UyEFI1N1Vz5VZlA6VWIHaAQpADZVYl0uVGQDNwZ+XDZVYghmUGJTPlMzBGZQY1JoAzQEOgMyBm4HY1c1UDJZPFNiBWBTNlc0VTBQa1VpB20EYwA2VTBdZFRhAzUGaVwvVXMIP1B0UyFTJwQtUDBSfwNoBGcDOAZrBzFXZVAxWTRTPwVnUyNXd1U9UGdVNQc+BDsANlVlXTFUYAMwBmVcNVUyCGdQMlMpU3wEeFAzUmEDdgQ+AzQGbAc2V2JQNFkwUzQFYlM1VztVclB/VSAHLwQ7ADZVZV0xVGADMAZiXDdVNghpUD5TIVMnBDdQJVIwAzMENAMrBmsHPldhUClZNVMyBWFTK1c7VWU=" title="五子棋.rar">五子棋.rar</a><br>备用下载链接：<a href="https://wws.lanzous.com/io8AHidxk2b" title="五子棋.rar">五子棋.rar</a></p><p><strong>关于此游戏的改进建议以及意见，欢迎下方评论留言！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>评论功能上线啦</title>
      <link href="2020/11/08/comment-function/"/>
      <url>2020/11/08/comment-function/</url>
      
        <content type="html"><![CDATA[<p>大家可以在下方评论体验！（需要花2秒钟登录）</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
